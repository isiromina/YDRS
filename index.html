<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>✨ AI 기반 실시간 재난 현황 대시보드</title>
    
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- Leaflet CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Marked.js for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- EmailJS SDK -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@emailjs/browser@4/dist/email.min.js"></script>

    <style>
        /* 기본 스타일 및 레이아웃 */
        * { box-sizing: border-box; }
        body { margin: 0; font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); color: #333; }
        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }
        header { 
            margin-bottom: 2rem; 
            display: flex; 
            justify-content: space-between; /* 양쪽 끝으로 요소 분리 */
            align-items: center; 
            flex-wrap: wrap; 
            gap: 1.5rem; 
            border-bottom: 1px solid rgba(0, 0, 0, 0.1); 
            padding-bottom: 2rem; 
        }
        header h1 { font-size: 2.25rem; font-weight: 700; color: #4a5568; }
        header p { margin-top: 0.5rem; color: #4a5568; }

        /* 버튼 스타일 */
        .btn { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); border: none; color: white; padding: 0.6rem 1.2rem; border-radius: 25px; font-size: 0.875rem; font-weight: 600; cursor: pointer; box-shadow: 0 4px 15px rgba(0,0,0,0.2); transition: all 0.3s ease; white-space: nowrap; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        .btn-danger { background: linear-gradient(135deg,#e53935 0%,#b71c1c 100%); }
        .ai-action-btn { background: #3b82f6; border: none; color: white; padding: 0.4rem 0.8rem; border-radius: 5px; font-size: 0.75rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; }
        .ai-action-btn:hover { background: #2563eb; transform: translateY(-1px); }

        /* 섹션 및 콘텐츠 스타일 */
        main section { margin-bottom: 2rem; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 15px; padding: 2rem; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); }
        .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; }
        main h2 { font-size: 1.75rem; font-weight: 600; color: #2d3748; margin-bottom: 0.5rem; }
        main .section-subtitle { color: #4a5568; margin-bottom: 1.5rem; }
        #map { width: 100%; height: 65vh; border-radius: 10px; background: #f0f0f0; }
        table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
        th, td { border: 1px solid #e2e8f0; padding: 0.85rem 1rem; text-align: center; vertical-align: middle; }
        th { background: #f7fafc; font-weight: 600; }

        /* 모달 스타일 */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        .modal-overlay.flex { display: flex; }
        .modal-content { background: #ffffff; border-radius: 15px; width: 100%; max-width: 42rem; max-height: 90vh; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; padding: 1.5rem; border-bottom: 1px solid #e2e8f0; }
        .modal-close-btn { background: none; border: none; font-size: 1.75rem; cursor: pointer; }
        .modal-body { padding: 1.5rem; overflow-y: auto; }
        #settings-form { display: flex; flex-direction: column; gap: 1rem; }
        #settings-form input, #settings-form select { padding: 0.75rem; border: 1px solid #ccc; border-radius: 8px; }
        #contacts-list { list-style: none; padding: 0; margin-top: 1.5rem; }
        #contacts-list li { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; border-bottom: 1px solid #e2e8f0; }
        .delete-contact-btn { background: #ef4444; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; }
    </style>
</head>
<body>
<div class="container">
    <header>
        <div>
            <h1 data-lang-key="mainTitle"></h1>
            <p data-lang-key="mainSubtitle"></p>
        </div>
        <div id="lang-switcher" style="display:flex;gap:0.5rem; align-self: flex-start; margin-top: 0;">
            <button data-lang="ko" class="btn">🇰🇷 KO</button>
            <button data-lang="en" class="btn">🇺🇸 EN</button>
        </div>
    </header>
    <main>
        <section id="map-section">
            <div class="section-header">
                <div>
                    <h2 data-lang-key="mapTitle"></h2>
                    <p class="section-subtitle" data-lang-key="mapSubtitle"></p>
                </div>
                <div style="display:flex;gap:0.5rem;align-items:center;">
                    <button id="toggle-map-btn" class="btn"></button>
                    <button id="clear-history-btn" class="btn btn-danger" data-lang-key="clearHistoryBtn"></button>
                </div>
            </div>
            <div id="map"></div>
        </section>
        <section id="table-section">
            <div class="section-header">
                <div>
                    <h2 data-lang-key="tableTitle"></h2>
                    <p class="section-subtitle" data-lang-key="tableSubtitle"></p>
                </div>
                <div style="display:flex;gap:0.5rem;align-items:center;">
                    <button id="manage-contacts-btn" class="btn" data-lang-key="manageContactsBtn">📇</button>
                    <button id="manual-notify-btn" class="btn" data-lang-key="manualNotifyBtn" style="display:none;"></button>
                </div>
            </div>
            <div style="overflow-x:auto;">
                <table>
                    <thead><tr id="table-header-row"></tr></thead>
                    <tbody id="distanceTableBody"></tbody>
                </table>
            </div>
        </section>
    </main>
</div>
    
    <div id="ai-modal" class="modal-overlay">
        <div class="modal-content">
            <header class="modal-header">
                <h3 id="ai-modal-title"></h3>
                <button id="ai-modal-close" class="modal-close-btn">&times;</button>
            </header>
            <div id="ai-modal-content" class="modal-body" style="white-space: pre-wrap;"></div>
        </div>
    </div>
    
<div id="settings-modal" class="modal-overlay">
    <div class="modal-content">
        <header class="modal-header">
            <h3 data-lang-key="settingsModalTitle"></h3>
            <button id="settings-modal-close" class="modal-close-btn">&times;</button>
        </header>
        <div class="modal-body">
            <form id="settings-form">
                <input type="text" id="contact-name" placeholder="이름" required>
                <input type="email" id="contact-email" placeholder="이메일 주소" required>
                <select id="contact-factory-select"></select>
                <button type="submit" class="btn" data-lang-key="addContactBtn"></button>
            </form>
            <ul id="contacts-list"></ul>
        </div>
    </div>
</div>

    <script>
        // --- 1. CONFIGURATION & CONSTANTS ---
        // =======================================================
        // ✨ 이 부분은 실행 환경에서 자동으로 채워집니다.
        // =======================================================
        const GEMINI_API_KEY = ""; // 이 키는 실행 환경에서 자동으로 제공됩니다.
        
        // EmailJS 키 (이전 버전에서 사용하던 키를 다시 사용)
        const EMAILJS_PUBLIC_KEY = "7piqAcEBAyDl2ac9-"; 
        const EMAILJS_SERVICE_ID = "service_7fp4k9e";
        const EMAILJS_TEMPLATE_ID = "template_8xzncvb";

        // 재난 위험에 노출될 수 있는 공장 위치 데이터
        // NOTE: 이메일 알림을 위해 각 공장에 'country' 정보를 추가했습니다.
        const factories = {
            "R&D Center": {lat: 37.4028781, lng: 127.1080751, country: 'KOREA'}, "CHEONGBUK": {lat: 37.0432081, lng: 126.9488081, country: 'KOREA'},
            "JANGAN": {lat: 37.0617091, lng: 126.8516081, country: 'KOREA'}, "JINWI": {lat: 37.1135291, lng: 127.0646151, country: 'KOREA'}, "CHEONGJU": {lat: 36.6326841, lng: 127.3074351, country: 'KOREA'},
            "GYEONGJU": {lat: 35.8710891, lng: 129.0705691, country: 'KOREA'}, "JUNDONG": {lat: 36.6421561, lng: 127.2760631, country: 'KOREA'}, "BEIJING": {lat: 40.3584486, lng: 116.8131146, country: 'CHINA'},
            "WEIHAI": {lat: 37.3701011, lng: 122.2203763, country: 'CHINA'}, "RONGCHENG": {lat: 37.1447568, lng: 122.4544656, country: 'CHINA'}, "HEZE": {lat: 35.2431127, lng: 115.5612442, country: 'CHINA'},
            "LELING": {lat: 37.7332868, lng: 117.1757121, country: 'CHINA'}, "VIETNAM": {lat: 20.9714435, lng: 105.9899378, country: 'VIETNAM'}, "SERBIA LESKOVAC": {lat: 43.0142517, lng: 21.9588845, country: 'SERBIA'},
            "SERBIA RACA": {lat: 44.2471316, lng: 20.9899691, country: 'SERBIA'}, "SERBIA NIS": {lat: 43.3113091, lng: 21.8318674, country: 'SERBIA'}, "SLOVAKIA LEDNICKE": {lat: 49.0720488, lng: 18.2989662, country: 'SLOVAKIA'},
            "SLOVAKIA SOBOTA": {lat: 48.3778118, lng: 20.0136771, country: 'SLOVAKIA'}, "MEXICO TORREON": {lat: 25.4720401, lng: -103.3606821, country: 'MEXICO'}, "MEXICO DURANGO": {lat: 25.8341065, lng: -103.8415915, country: 'MEXICO'},
            "MEXICO LERDO": {lat: 25.5634585, lng: -103.5213405, country: 'MEXICO'}, "MEXICO MONTERRAY": {lat: 25.7585854, lng: -99.9957003, country: 'MEXICO'}, "TUNISIA": {lat: 35.6939288, lng: 10.1124129, country: 'TUNISIA'},
            "MORROCO": {lat: 33.8612668, lng: -5.5831826, country: 'MOROCCO'}, "ALBANIA": {lat: 40.7146584, lng: 19.5492341, country: 'ALBANIA'}, "RUS": {lat: 59.3765474, lng: 28.2204991, country: 'RUSSIA'},
            "POLAND": {lat: 51.0365921, lng: 16.8978391, country: 'POLAND'}, "CZECH": {lat: 49.7794629, lng: 18.4498011, country: 'CZECHIA'}, "UK": {lat: 52.4682403, lng: -1.2716024, country: 'UK'}
        };

        // 다국어 지원을 위한 번역 데이터
        const translations = {
            ko: {
                mainTitle: "✨ AI 기반 실시간 재난 현황 대시보드", mainSubtitle: "GDACS 데이터를 기반으로 재난 정보를 시각화하고, Gemini AI를 통해 맞춤형 대응 방안을 생성합니다.",
                mapTitle: "누적 재난 지도", clearHistoryBtn: "이력 초기화 ↻", mapSubtitle: "지금까지 감지된 모든 재난의 위치를 지도에서 확인하세요.",
                tableTitle: "위험 근접 공장 목록", tableSubtitle: "감지된 재난으로부터 1500km 이내에 위치한 공장 목록입니다.",
                tableHeaders: ["공장명", "재난 유형", "거리 (km)", "발생 시각", "강도", "경고 수준", "✨ AI 대응 방안"],
                alertLevels: { safe: "안전", caution: "주의", warning: "경계", severe: "심각" },
                // 산불(wildfire) 추가
                disasterTypes: { typhoon: "태풍", earthquake: "지진", flood: "홍수", volcano: "화산", wildfire: "산불" },
                status: { loading: "로딩 중...", noDisaster: "누적된 재난 정보가 없습니다.", noAffected: "1500km 이내 위험에 처한 공장이 없습니다.", error: "오류", generate: "생성" },
                toggleMapBtn: "🛰️ 위성 지도", toggleMapBtnStyled: "🗺️ 기본 지도",
                manageContactsBtn: "알림 대상 관리", settingsModalTitle: "알림 대상 연락처 관리", addContactBtn: "연락처 추가",
                manualNotifyBtn: "📧 이메일 전송",
                notificationTitle: "🚨 긴급 재난 알림",
            },
            en: {
                mainTitle: "✨ AI-Powered Real-Time Disaster Dashboard", mainSubtitle: "Visualize disaster data from GDACS and generate custom action plans with Gemini AI.",
                mapTitle: "Cumulative Disaster Map", clearHistoryBtn: "Clear History ↻", mapSubtitle: "View all detected disasters on the map.",
                tableTitle: "At-Risk Factory List", tableSubtitle: "Factories located within 1500km of a detected disaster.",
                tableHeaders: ["Factory", "Disaster", "Distance (km)", "Time", "Severity", "Alert Level", "✨ AI Action Plan"],
                alertLevels: { safe: "Safe", caution: "Caution", warning: "Warning", severe: "Severe" },
                // Wildfire added
                disasterTypes: { typhoon: "Typhoon", earthquake: "Earthquake", flood: "Flood", volcano: "Volcano", wildfire: "Wildfire" },
                status: { loading: "Loading...", noDisaster: "No cumulative disaster data.", noAffected: "No factories are at risk within 1500km.", error: "Error", generate: "Generate" },
                toggleMapBtn: "🛰️ Satellite Map", toggleMapBtnStyled: "🗺️ Styled Map",
                manageContactsBtn: "Manage Contacts", settingsModalTitle: "Manage Notification Contacts", addContactBtn: "Add Contact",
                manualNotifyBtn: "📧 Send Email",
                notificationTitle: "🚨 URGENT DISASTER ALERT",
            }
        };

        // --- 2. STATE MANAGEMENT ---
        let currentLanguage = localStorage.getItem('disasterDashboardLanguage') || 'ko';
        let leafletMap, styledMapLayer, satelliteLayer, disasterLayerGroup;
        let cumulativeDisasters = [];
        let affectedFactoryList = [];
        let currentMapTypeId = 'styled_map';
        let registeredContacts = [];
        let notificationLog = {};
        
        // --- 3. UTILITY & HELPER FUNCTIONS ---
        // 하버사인 공식으로 두 지점 간 거리(km)를 계산
        const toRad = (v) => v * Math.PI / 180;
        const haversineDistance = (c1, c2) => { const R = 6371; const dLat = toRad(c2.lat - c1.lat); const dLon = toRad(c2.lng - c1.lng); const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(c1.lat)) * Math.cos(toRad(c2.lat)) * Math.sin(dLon / 2) ** 2; return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)); };
        
        // 거리에 따른 경고 수준 결정
        const getAlertLevelKey = (d) => { if (d > 200) return 'safe'; if (d > 100) return 'caution'; if (d > 50) return 'warning'; return 'severe'; };
        
        // XML 데이터 파싱
        const getTagText = (item, tag) => item.querySelector(tag)?.textContent.trim() || null;
        
        // 로컬 스토리지 관련 유틸리티
        const getStoredDisasters = () => JSON.parse(localStorage.getItem('cumulativeDisasters')) || [];
        const setStoredDisasters = (d) => localStorage.setItem('cumulativeDisasters', JSON.stringify(d));
        const saveContacts = () => localStorage.setItem('disasterContacts', JSON.stringify(registeredContacts));
        const loadContacts = () => JSON.parse(localStorage.getItem('disasterContacts')) || [];
        const loadNotificationLog = () => JSON.parse(localStorage.getItem('notificationLog')) || {};
        const saveNotificationLog = (log) => localStorage.setItem('notificationLog', JSON.stringify(log));

        // --- 4. CORE DATA & API LOGIC ---
        // GDACS RSS 피드에서 재난 데이터 가져오기
        async function fetchDisasters() {
            const PROXY_URL = "https://api.allorigins.win/raw?url=";
            const RSS_URL = "https://www.gdacs.org/xml/rss_24h.xml";
            const maxRetries = 3;
            let retries = 0;
            
            while (retries < maxRetries) {
                try {
                    const response = await fetch(`${PROXY_URL}${encodeURIComponent(RSS_URL)}`, { signal: AbortSignal.timeout(15000) });
                    if (!response.ok) {
                        if (response.status === 429) { // Too many requests
                            console.warn(`Retry ${retries + 1}/${maxRetries}: Too many requests. Waiting for 2 seconds...`);
                            await new Promise(resolve => setTimeout(resolve, 2000));
                            retries++;
                            continue;
                        }
                        throw new Error(`Network response was not ok: ${response.statusText}`);
                    }
                    const xmlText = await response.text();
                    const xml = new DOMParser().parseFromString(xmlText, "application/xml");
                    if (xml.querySelector("parsererror")) throw new Error("XML parsing error.");
                    
                    return Array.from(xml.querySelectorAll("item")).map(item => {
                        const typeRaw = item.querySelector("gdacs\\:eventtype, eventtype")?.textContent.toLowerCase() || '';
                        const mapping = { 'tc': 'typhoon', 'eq': 'earthquake', 'fl': 'flood', 'vo': 'volcano', 'wf': 'wildfire' };
                        const typeKey = Object.keys(mapping).find(k => typeRaw.includes(k));
                        if (!typeKey) return null;

                        let eventName = item.querySelector("gdacs\\:eventname, eventname")?.textContent || "";
                        const fromDate = item.querySelector("gdacs\\:fromdate, fromdate")?.textContent || new Date().toISOString();
                        const lat = parseFloat(item.querySelector("geo\\:lat, lat")?.textContent);
                        const lon = parseFloat(item.querySelector("geo\\:long, long")?.textContent);
                        if (isNaN(lat) || isNaN(lon)) return null;

                        if (typeKey === 'earthquake' && (eventName === "" || eventName.includes("Unnamed"))) {
                            const countryName = item.querySelector("gdacs\\:countryname, countryname")?.textContent;
                            eventName = countryName ? `${countryName} Earthquake` : "Unspecified Location Earthquake";
                        }

                        const severityTag = item.querySelector("gdacs\\:severity, severity");
                        let severity = "-";
                        if (severityTag) {
                            const unit = severityTag.getAttribute("unit");
                            const valueAttr = severityTag.getAttribute("value") || "";
                            const numericValue = parseFloat(valueAttr.replace(/[^0-9.-]/g, ''));

                            if (typeKey === 'flood' && numericValue === 0) {
                                severity = "-";
                            } else if (!isNaN(numericValue)) {
                                if (unit === "M") {
                                    severity = `Mag ${numericValue.toFixed(1)}`;
                                } else if (unit === "km/h" || typeKey === 'typhoon') {
                                    severity = `Wind ${numericValue.toFixed(2)} km/h`;
                                } else {
                                    severity = `${unit || 'Val'}: ${numericValue.toFixed(2)}`;
                                }
                            } else {
                                severity = valueAttr;
                            }
                        }
                        return { id: `${eventName}-${fromDate}`, eventName, typeKey: mapping[typeKey], location: { lat, lng: lon }, severity, time: fromDate };
                    }).filter(Boolean);

                } catch (e) {
                    retries++;
                    console.error(`Attempt ${retries} failed: ${e.message}. Retrying...`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * retries));
                }
            }
            
            throw new Error(`Failed to fetch data after ${maxRetries} attempts. Please check your network connection.`);
        }
        
        // Gemini AI를 사용하여 재난 대응 방안 생성
        async function generateActionPlan(disaster, factory) {
            const t = translations[currentLanguage];
            const prompt = `You are a crisis management expert. For a ${disaster.typeKey} named '${disaster.eventName}' (${disaster.severity}) that is ${factory.distance.toFixed(1)} km away from the '${factory.factoryName}' factory, provide a concise, bulleted list of immediate action items in ${currentLanguage === 'ko' ? 'Korean' : 'English'}.`;
            
            const model = 'gemini-2.5-flash-preview-05-20';
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${GEMINI_API_KEY}`;
            
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });
            if (!response.ok) throw new Error(`Gemini API Error (HTTP ${response.status})`);
            const result = await response.json();
            return result.candidates?.[0]?.content?.parts?.[0]?.text || "No response from AI.";
        }

        // 재난 데이터와 공장 위치를 비교하여 위험 공장 목록 생성
        function processDisasterData() {
            affectedFactoryList = [];
            if (cumulativeDisasters.length === 0) return;
            cumulativeDisasters.forEach((disaster, disasterIndex) => {
                Object.entries(factories).forEach(([factoryName, factoryLocation]) => {
                    const distance = haversineDistance(disaster.location, factoryLocation);
                    // NOTE: 위험 근접 거리 임계값을 1500km로 복원했습니다.
                    if (distance <= 1500) {
                        affectedFactoryList.push({ factoryName, disaster, disasterIndex, distance });
                    }
                });
            });
            affectedFactoryList.sort((a, b) => a.distance - b.distance);
        }

        // --- 5. NOTIFICATION LOGIC ---
        // EmailJS를 사용하여 이메일 전송
        async function sendEmail(contact, subject, message) {
            try {
                await emailjs.send(EMAILJS_SERVICE_ID, EMAILJS_TEMPLATE_ID, {
                    to_name: contact.name,
                    to_email: contact.email,
                    subject: subject,
                    message: message
                }, EMAILJS_PUBLIC_KEY);
                console.log(`Email sent to ${contact.email} successfully.`);
            } catch (error) {
                console.error(`Failed to send email to ${contact.email}:`, error);
            }
        }

        // 알림 전송 (수동 또는 자동)
        async function sendNotifications(isManual = false) {
            const t = translations[currentLanguage];
            const subject = t.notificationTitle;
            
            // 모든 위험 공장 데이터를 국가별로 그룹화
            const affectedFactoriesByCountry = affectedFactoryList.reduce((acc, item) => {
                const country = factories[item.factoryName]?.country;
                if (country) {
                    if (!acc[country]) {
                        acc[country] = [];
                    }
                    acc[country].push(item);
                }
                return acc;
            }, {});

            if (Object.keys(affectedFactoriesByCountry).length === 0) {
                if (isManual) alert(t.status.noAffected);
                return;
            }

            // 등록된 연락처를 순회하며 각 연락처에 맞는 메일을 생성 및 발송
            for (const contact of registeredContacts) {
                const contactCountry = factories[contact.factory]?.country;
                if (!contactCountry) continue;

                const nearbyFactoriesInCountry = affectedFactoriesByCountry[contactCountry];
                
                // 해당 국가의 위험 공장 정보가 없는 경우 건너뜁니다.
                if (!nearbyFactoriesInCountry || nearbyFactoriesInCountry.length === 0) {
                    continue;
                }
                
                // 이메일 HTML 콘텐츠 생성
                const tableStyle = "style='width: 100%; border-collapse: collapse; font-family: sans-serif; font-size: 14px;'";
                const thStyle = "style='background-color: #f8f9fa; padding: 12px; text-align: left; border-bottom: 2px solid #dee2e6; font-weight: 600;'";
                const tdStyle = "style='padding: 12px; text-align: left; border-bottom: 1px solid #dee2e6;'";
                const linkStyle = "style='color: #007bff; text-decoration: none;'";

                const tableRows = nearbyFactoriesInCountry.map(subItem => `
                    <tr>
                        <td ${tdStyle}>${subItem.factoryName}</td>
                        <td ${tdStyle}>${t.disasterTypes[subItem.disaster.typeKey]}</td>
                        <td ${tdStyle}>${subItem.disaster.severity}</td>
                        <td ${tdStyle}>${new Date(subItem.disaster.time).toLocaleString(currentLanguage === 'ko' ? 'ko-KR' : 'en-US')}</td>
                        <td ${tdStyle}>${subItem.distance.toFixed(1)} km</td>
                    </tr>
                `).join('');

                const introText = currentLanguage === 'ko' ? `[${contact.factory}] 공장과 인근 지역에 재난 위험이 감지되었습니다. 다음은 ${contactCountry} 내의 위험 근접 공장 목록입니다:` : `A disaster alert has been issued for [${contact.factory}] and nearby areas. Below is a list of at-risk factories in ${contactCountry}:`;
                const viewDashboardText = currentLanguage === 'ko' ? '자세한 내용은 대시보드에서 확인하세요:' : 'For more details, please visit the dashboard:';

                const emailHtml = `
                    <div style="font-family: Arial, sans-serif; color: #333;">
                        <p>${introText}</p>
                        <table ${tableStyle}>
                            <thead>
                                <tr>
                                    <th ${thStyle}>${currentLanguage === 'ko' ? '공장명' : 'Factory'}</th>
                                    <th ${thStyle}>${currentLanguage === 'ko' ? '재난 유형' : 'Disaster'}</th>
                                    <th ${thStyle}>${currentLanguage === 'ko' ? '강도' : 'Severity'}</th>
                                    <th ${thStyle}>${currentLanguage === 'ko' ? '발생 시각' : 'Time'}</th>
                                    <th ${thStyle}>${currentLanguage === 'ko' ? '거리' : 'Distance'}</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                        <p style="margin-top: 24px;">
                            ${viewDashboardText}<br>
                            <a href="https://isiromina.github.io/YDRS/" ${linkStyle}>https://isiromina.github.io/YDRS/</a>
                        </p>
                    </div>
                `;
                
                await sendEmail(contact, subject, emailHtml);
            }

            if (isManual) {
                alert(`알림이 위험 근접 공장 관련 연락처로 전송되었습니다.`);
            }
        }
        
        // 자동 알림 로직
        async function handleAutomaticNotifications() {
            const now = Date.now();
            const oneHour = 60 * 60 * 1000;

            const uniqueDisastersInList = cumulativeDisasters.filter(disaster => 
                affectedFactoryList.some(item => item.disaster.id === disaster.id)
            );

            const disasterIdsToNotify = new Set();
            for (const disaster of uniqueDisastersInList) {
                const lastSent = notificationLog[disaster.id] || 0;
                if (!lastSent || (now - lastSent > oneHour)) {
                    disasterIdsToNotify.add(disaster.id);
                }
            }

            if (disasterIdsToNotify.size > 0) {
                const itemsToNotify = affectedFactoryList.filter(item => disasterIdsToNotify.has(item.disaster.id));
                
                if (itemsToNotify.length > 0) {
                    await sendNotifications(false);
                    disasterIdsToNotify.forEach(id => {
                        notificationLog[id] = now;
                    });
                    saveNotificationLog(notificationLog);
                }
            }
        }

        // --- 6. UI RENDERING & DOM MANIPULATION ---
        // UI 텍스트 업데이트
        function updateStaticUI(lang) {
            const t = translations[lang];
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-lang-key]').forEach(el => { el.textContent = t[el.dataset.langKey] || ''; });
            document.querySelectorAll('#lang-switcher button').forEach(btn => btn.style.background = btn.dataset.lang === lang ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)' : '');
            document.getElementById('table-header-row').innerHTML = t.tableHeaders.map(h => `<th>${h}</th>`).join('');
            document.getElementById('toggle-map-btn').textContent = (currentMapTypeId === 'styled_map') ? t.toggleMapBtn : t.toggleMapBtnStyled;
            // contact placeholder를 한국어로 업데이트
            document.getElementById('contact-name').placeholder = lang === 'ko' ? '이름' : 'Name';
            document.getElementById('contact-email').placeholder = lang === 'ko' ? '이메일 주소' : 'Email Address';
        }

        // 동적 콘텐츠(지도 마커 및 테이블) 렌더링
        function renderContent(lang) {
            const tbody = document.getElementById('distanceTableBody');
            const t = translations[lang];
            disasterLayerGroup.clearLayers();
            
            // 재난 유형별 마커 색상 정의에 산불(wildfire) 추가
            const markerColors = {
                typhoon: '#E53935', earthquake: '#1E88E5', flood: '#43A047', volcano: '#FF9800', wildfire: '#FF4500' 
            };
            
            // 태풍 경로를 위한 별도 레이어 그룹
            const typhoonPathLayer = L.layerGroup().addTo(leafletMap);

            cumulativeDisasters.forEach(disaster => {
                const marker = L.circleMarker(disaster.location, { radius: 8, color: "#fff", weight: 2, fillColor: markerColors[disaster.typeKey], fillOpacity: 0.9 }).addTo(disasterLayerGroup);
                marker.bindTooltip(`<strong>${disaster.eventName}</strong><br>${t.disasterTypes[disaster.typeKey]} | ${disaster.severity}<br>${new Date(disaster.time).toLocaleString(lang === 'ko' ? 'ko-KR' : 'en-US')}`);
            
                // 태풍일 경우 경로를 그리는 로직 추가
                if (disaster.typeKey === 'typhoon') {
                    // 동일한 태풍 이벤트의 모든 위치 기록을 필터링
                    const typhoonPath = cumulativeDisasters
                        .filter(d => d.eventName === disaster.eventName && d.typeKey === 'typhoon')
                        .sort((a, b) => new Date(a.time) - new Date(b.time))
                        .map(d => [d.location.lat, d.location.lng]);

                    if (typhoonPath.length > 1) {
                        L.polyline(typhoonPath, { color: '#4a90e2', weight: 3, dashArray: '5, 10' }).addTo(typhoonPathLayer);
                    }
                }
            });
            
            const showButtons = affectedFactoryList.length > 0;
            document.getElementById('manual-notify-btn').style.display = showButtons ? 'inline-block' : 'none';
            document.getElementById('manage-contacts-btn').style.display = showButtons ? 'inline-block' : 'none';

            if (affectedFactoryList.length === 0) {
                tbody.innerHTML = `<tr><td colspan="7">${cumulativeDisasters.length === 0 ? t.status.noDisaster : t.status.noAffected}</td></tr>`;
            } else {
                tbody.innerHTML = affectedFactoryList.map(item => {
                    const { factoryName, disaster, disasterIndex, distance } = item;
                    const alertLevelKey = getAlertLevelKey(distance);
                    return `<tr data-disaster-index="${disasterIndex}" data-factory-name="${factoryName}" data-distance="${distance}">
                        <td>${factoryName}</td>
                        <td>${t.disasterTypes[item.disaster.typeKey]}</td><td>${distance.toFixed(1)}</td>
                        <td>${new Date(item.disaster.time).toLocaleString(lang === 'ko' ? 'ko-KR' : 'en-US')}</td><td>${disaster.severity}</td>
                        <td>${t.alertLevels[alertLevelKey]}</td>
                        <td><button class="ai-action-btn">${t.status.generate}</button></td>
                    </tr>`;
                }).join('');
            }
        }

        // GDACS 데이터 가져오기 및 UI 업데이트
        async function fetchAndUpdateData() {
            try {
                const newDisasters = await fetchDisasters();
                const storedIds = new Set(cumulativeDisasters.map(d => d.id));
                const trulyNewDisasters = newDisasters.filter(d => !storedIds.has(d.id));
                
                if (trulyNewDisasters.length > 0) {
                    cumulativeDisasters = [...trulyNewDisasters, ...cumulativeDisasters];
                    setStoredDisasters(cumulativeDisasters);
                    processDisasterData();
                    renderContent(currentLanguage);
                    await handleAutomaticNotifications();
                }
            } catch (err) {
                const tbody = document.getElementById('distanceTableBody');
                tbody.innerHTML = `<tr><td colspan="7" style="color:#ff6b6b;">${translations[currentLanguage].status.error}: ${err.message}</td></tr>`;
            }
        }

        // --- 7. EVENT LISTENERS & INITIALIZATION ---
        // 언어 변경
        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('disasterDashboardLanguage', lang);
            updateStaticUI(lang);
            renderContent(lang);
        }

        // 지도 타입 변경
        function toggleMapType() {
            if (leafletMap.hasLayer(styledMapLayer)) {
                leafletMap.removeLayer(styledMapLayer);
                leafletMap.addLayer(satelliteLayer);
                currentMapTypeId = 'satellite';
            } else {
                leafletMap.removeLayer(satelliteLayer);
                leafletMap.addLayer(styledMapLayer);
                currentMapTypeId = 'styled_map';
            }
            updateStaticUI(currentLanguage);
        }

        // 연락처 목록 렌더링
        function renderContactsList() {
            document.getElementById('contacts-list').innerHTML = registeredContacts.map((contact, index) =>
                `<li><div><strong>${contact.name}</strong><br><small>${contact.email} (${contact.factory})</small></div>
                 <button class="delete-contact-btn" data-index="${index}">&times;</button></li>`
            ).join('');
        }

        // 페이지 로드 시 초기화
        document.addEventListener('DOMContentLoaded', () => {
            // 지도 초기화
            leafletMap = L.map('map', { worldCopyJump: true }).setView([30, 120], 3);
            styledMapLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap' }).addTo(leafletMap);
            satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '&copy; Esri' });
            disasterLayerGroup = L.layerGroup().addTo(leafletMap);
            
            // 공장 마커 추가
            Object.entries(factories).forEach(([name, loc]) => {
                L.circleMarker(loc, { radius: 4, color: '#000', weight: 1, fillColor: "#FFC107", fillOpacity: 0.9 }).addTo(leafletMap).bindTooltip(name);
            });

            // 데이터 로드 및 렌더링
            registeredContacts = loadContacts();
            notificationLog = loadNotificationLog();
            cumulativeDisasters = getStoredDisasters();
            processDisasterData();
            setLanguage(currentLanguage);
            
            // 주기적으로 데이터 업데이트
            fetchAndUpdateData();
            setInterval(fetchAndUpdateData, 300000); // 5분마다 업데이트

            // 이벤트 리스너
            document.getElementById('lang-switcher').addEventListener('click', e => e.target.dataset.lang && setLanguage(e.target.dataset.lang));
            document.getElementById('toggle-map-btn').addEventListener('click', toggleMapType);
            document.getElementById('clear-history-btn').addEventListener('click', () => {
                cumulativeDisasters = []; 
                setStoredDisasters([]); 
                notificationLog = {};
                saveNotificationLog({});
                processDisasterData(); 
                renderContent(currentLanguage);
            });
            document.getElementById('distanceTableBody').addEventListener('click', async (e) => {
                const row = e.target.closest('tr');
                if (!row) return;
                
                if (e.target.classList.contains('ai-action-btn')) {
                    const disaster = cumulativeDisasters[parseInt(row.dataset.disasterIndex)];
                    const factory = { factoryName: row.dataset.factoryName, distance: parseFloat(row.dataset.distance) };
                    const modal = document.getElementById('ai-modal');
                    const modalTitle = document.getElementById('ai-modal-title');
                    const modalContent = document.getElementById('ai-modal-content');
                    modalTitle.textContent = "AI 분석 중...";
                    modalContent.textContent = "";
                    modal.classList.add('flex');
                    try {
                        const plan = await generateActionPlan(disaster, factory);
                        modalTitle.textContent = `AI 대응 방안: ${factory.factoryName}`;
                        modalContent.innerHTML = marked.parse(plan);
                    } catch (err) {
                        modalTitle.textContent = "오류 발생";
                        modalContent.textContent = err.message;
                    }
                }
            });

            // 모달 관련 이벤트 리스너
            const aiModal = document.getElementById('ai-modal');
            const settingsModal = document.getElementById('settings-modal');
            document.getElementById('ai-modal-close').addEventListener('click', () => aiModal.classList.remove('flex'));
            document.getElementById('manage-contacts-btn').addEventListener('click', () => { 
                renderContactsList(); 
                populateFactorySelect();
                settingsModal.classList.add('flex'); 
            });
            document.getElementById('settings-modal-close').addEventListener('click', () => settingsModal.classList.remove('flex'));
            document.getElementById('settings-form').addEventListener('submit', (e) => {
                e.preventDefault();
                registeredContacts.push({ 
                    name: e.target.elements['contact-name'].value, 
                    email: e.target.elements['contact-email'].value,
                    factory: e.target.elements['contact-factory-select'].value
                });
                saveContacts(); renderContactsList(); e.target.reset();
            });
            document.getElementById('contacts-list').addEventListener('click', e => {
                if (e.target.classList.contains('delete-contact-btn')) {
                    registeredContacts.splice(parseInt(e.target.dataset.index), 1);
                    saveContacts(); renderContactsList();
                }
            });
            document.getElementById('manual-notify-btn').addEventListener('click', () => sendNotifications(true));
        });

        // 공장 드롭다운 메뉴 채우기
        function populateFactorySelect() {
            const select = document.getElementById('contact-factory-select');
            select.innerHTML = '<option value="">-- 공장 선택 --</option>';
            const factoryNames = Object.keys(factories);
            factoryNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }
    </script>
</body>
</html>
